{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"docs/","title":"Python Docs","text":"<p>A high-level overview of writing and previewing the Rerun python documentation.</p>"},{"location":"docs/#getting-started-with-docs","title":"Getting started with docs","text":""},{"location":"docs/#dependencies","title":"Dependencies","text":"<p>All of the dependencies for documentation generation are captured in the requirements file:</p> <pre><code>pip install -r rerun_py/requirements-doc.txt\n</code></pre>"},{"location":"docs/#serving-the-docs-locally","title":"Serving the docs locally","text":"<p>The docs can be previewed locally using <code>mkdocs</code></p> <p>This will watch the contents of the <code>rerun_py</code> folder and refresh documentation live as files are changed.</p> <pre><code>mkdocs serve -f rerun_py/mkdocs.yml -w rerun_py\n</code></pre> <p>or</p> <pre><code>just serve-py-docs\n</code></pre>"},{"location":"docs/#how-versioned-docs-are-generated-and-served","title":"How versioned docs are generated and served","text":"<p>Our documentation is versioned with releases and generated via mike</p> <p>The documentation exists as a Github Pages project which is hosted from the contents of the <code>gh-pages</code> branch.</p> <p><code>mike</code> updates this branch with new content as part of CI</p> <p>Every commit that lands to main will generate bleeding edge documentation as HEAD. Behind the scenes, a github action is just running:</p> <pre><code>mike deploy -F rerun_py/mkdocs.yml HEAD\n</code></pre> <p>On release, when github sees a new tag: <code>X.Y.Z</code>, the github action will instead deploy with a version tag:</p> <pre><code>mike deploy -F rerun_py/mkdocs.yml X.Y.Z latest\n</code></pre> <p>You can also locally preview the publicly hosted site with all versions, using mike:</p> <pre><code>mike serve -F rerun_py/mkdocs.yml\n</code></pre> <p>though when locally developing docs you are better off using <code>mkdocs serve</code> as described above since it will handle hot-reloading for you as you edit.</p>"},{"location":"common/","title":"Common APIs","text":"<p>Warning</p> <p>TODO(jleibs): Very high level pointers to common API groups</p>"},{"location":"common/images/","title":"Logging Images","text":""},{"location":"common/images/#rerun.log_image","title":"<code>def rerun.log_image(entity_path, image, *, timeless=False)</code>","text":"<p>Log a gray or color image.</p> <p>The image should either have 1, 3 or 4 channels (gray, RGB or RGBA).</p> <p>Supported <code>dtype</code>s: * uint8: color components should be in 0-255 sRGB gamma space, except for alpha which should be in 0-255 linear space. * uint16: color components should be in 0-65535 sRGB gamma space, except for alpha which should be in 0-65535 linear space. * float32/float64: all color components should be in 0-1 linear space.</p>"},{"location":"common/images/#rerun.log_image_file","title":"<code>def rerun.log_image_file(entity_path, img_path, img_format=None, timeless=False)</code>","text":"<p>Log the contents of an image file (only JPEGs supported for now).</p> <p>If no <code>img_format</code> is specified, we will try and guess it.</p>"},{"location":"common/images/#rerun.log_depth_image","title":"<code>def rerun.log_depth_image(entity_path, image, *, meter=None, timeless=False)</code>","text":"<p>Log a depth image.</p> <p>The image must be a 2D array. Supported <code>dtype</code>:s are: uint8, uint16, float32, float64</p> <p>meter: How long is a meter in the given dtype?        For instance: with uint16, perhaps meter=1000 which would mean        you have millimeter precision and a range of up to ~65 meters (2^16 / 1000).</p>"},{"location":"common/images/#rerun.log_segmentation_image","title":"<code>def rerun.log_segmentation_image(entity_path, image, *, timeless=False)</code>","text":"<p>Log an image made up of integer class-ids.</p> <p>The image should have 1 channel, i.e. be either <code>H x W</code> or <code>H x W x 1</code>.</p>"},{"location":"common/images/#rerun.log_annotation_context","title":"<code>def rerun.log_annotation_context(entity_path, class_descriptions, *, timeless=True)</code>","text":"<p>Log an annotation context made up of a collection of ClassDescriptions.</p> <p>Any entity needing to access the annotation context will find it by searching the path upward. If all entities share the same you can simply log it to the root (\"/\"), or if you want a per-entity ClassDescriptions log it to the same path as your entity.</p> <p>Each ClassDescription must include an annotation info with an id, which will be used for matching the class and may optionally include a label and color. Colors should either be in 0-255 gamma space or in 0-1 linear space. Colors can be RGB or RGBA.</p> <p>These can either be specified verbosely as:</p> <pre><code>[AnnotationInfo(id=23, label='foo', color=(255, 0, 0)), ...]\n</code></pre> <p>Or using short-hand tuples.</p> <pre><code>[(23, 'bar'), ...]\n</code></pre> <p>Unspecified colors will be filled in by the visualizer randomly.</p>"},{"location":"common/initialization/","title":"Initialization","text":""},{"location":"common/initialization/#rerun.init","title":"<code>def rerun.init(application_id, spawn_and_connect=False)</code>","text":"<p>Initialize the Rerun SDK with a user-chosen application id (name).</p> <p>Parameters:</p> Name Type Description Default <code>application_id</code> <code>str</code> <p>Your Rerun recordings will be categorized by this application id, so try to pick a unique one for each application that uses the Rerun SDK.</p> <p>For instance, if you have one application doing object detection and another doing camera calibration, you could have <code>rerun.init(\"object_detector\")</code> and <code>rerun.init(\"calibrator\")</code>.</p> required <p>spawn_and_connect : bool     Spawn a Rerun Viewer and stream logging data to it.     Short for calling <code>spawn_and_connect</code> separately.     If you don't call this, log events will be buffered indefinitely until     you call either <code>connect</code>, <code>show</code>, or <code>save</code></p>"},{"location":"common/initialization/#rerun.set_recording_id","title":"<code>def rerun.set_recording_id(value)</code>","text":"<p>Set the recording ID that this process is logging to, as a UUIDv4.</p> <p>The default recording_id is based on <code>multiprocessing.current_process().authkey</code> which means that all processes spawned with <code>multiprocessing</code> will have the same default recording_id.</p> <p>If you are not using <code>multiprocessing</code> and still want several different Python processes to log to the same Rerun instance (and be part of the same recording), you will need to manually assign them all the same recording_id. Any random UUIDv4 will work, or copy the recording id for the parent process.</p>"},{"location":"common/initialization/#rerun.connect","title":"<code>def rerun.connect(addr=None)</code>","text":"<p>Connect to a remote Rerun Viewer on the given ip:port.</p> <p>Requires that you first start a Rerun Viewer, e.g. with 'python -m rerun'</p>"},{"location":"common/initialization/#rerun.spawn_and_connect","title":"<code>def rerun.spawn_and_connect(port=9876)</code>","text":"<p>Spawn a Rerun Viewer and stream logging data to it.</p> <p>This is often the easiest and best way to use Rerun. Just call this once at the start of your program.</p> <p>See also: rerun.connect</p>"},{"location":"common/plotting/","title":"Plotting","text":""},{"location":"common/plotting/#rerun.log_scalar","title":"<code>def rerun.log_scalar(entity_path, scalar, label=None, color=None, radius=None, scattered=None)</code>","text":"<p>Log a double-precision scalar that will be visualized as a timeseries plot.</p> <p>The current simulation time will be used for the time/X-axis, hence scalars cannot be timeless!</p> <p>See also examples/plots.</p>"},{"location":"common/plotting/#rerun.log_scalar--understanding-the-plot-and-attributes-hierarchy","title":"Understanding the plot and attributes hierarchy","text":"<p>Timeseries come in three parts: points, lines and finally the plots themselves. As a user of the Rerun SDK, your one and only entrypoint into that hierarchy is through the lowest-level layer: the points.</p> <p>When logging scalars and their attributes (label, color, radius, scattered) through this function, Rerun will turn them into points with similar attributes. From these points, lines with appropriate attributes can then be inferred; and from these inferred lines, plots with appropriate attributes will be inferred in turn!</p> <p>In terms of actual hierarchy: - Each space represents a single plot. - Each entity path within a space that contains scalar data is a line within that plot. - Each logged scalar is a point.</p> <p>E.g. the following:</p> <pre><code>rerun.log_scalar(\"trig/sin\", sin(t), label=\"sin(t)\", color=RED)\nrerun.log_scalar(\"trig/cos\", cos(t), label=\"cos(t)\", color=BLUE)\n</code></pre> <p>will yield a single plot (space = <code>trig</code>), comprised of two lines (entity paths <code>trig/sin</code> and <code>trig/cos</code>).</p>"},{"location":"common/plotting/#rerun.log_scalar--attributes","title":"Attributes","text":"<p>The attributes you assigned (or not) to a scalar will affect all layers: points, lines and plots alike.</p>"},{"location":"common/plotting/#rerun.log_scalar--label","title":"<code>label</code>","text":"<p>An optional label for the point.</p> <p>This won't show up on points at the moment, as our plots don't yet support displaying labels for individual points.</p> <p>If all points within a single entity path (i.e. a line) share the same label, then this label will be used as the label for the line itself. Otherwise, the line will be named after the entity path.</p> <p>The plot itself is named after the space it's in.</p>"},{"location":"common/plotting/#rerun.log_scalar--color","title":"<code>color</code>","text":"<p>An optional color in the form of a RGB or RGBA triplet in 0-255 sRGB. If left unspecified, a pseudo-random color will be used instead. That same color will apply to all points residing in the same entity path that don't have a color specified.</p> <p>Points within a single line do not have to share the same color, the line will have differently colored segments as appropriate.</p> <p>If all points within a single entity path (i.e. a line) share the same color, then this color will be used as the line color in the plot legend. Otherwise, the line will appear grey in the legend.</p>"},{"location":"common/plotting/#rerun.log_scalar--radius","title":"<code>radius</code>","text":"<p>An optional radius for the point.</p> <p>Points within a single line do not have to share the same radius, the line will have differently sized segments as appropriate.</p> <p>If all points within a single entity path (i.e. a line) share the same radius, then this radius will be used as the line width too. Otherwise, the line will use the default width of <code>1.0</code>.</p>"},{"location":"common/plotting/#rerun.log_scalar--scattered","title":"<code>scattered</code>","text":"<p>Specifies whether the point should form a continuous line with its neighbours, or whether it should stand on its own, akin to a scatter plot.</p> <p>Points within a single line do not have to all share the same scatteredness: the line will switch between a scattered and a continous representation as required.</p>"},{"location":"common/primitives/","title":"Logging Primitives","text":""},{"location":"common/primitives/#rerun.log_point","title":"<code>def rerun.log_point(entity_path, position, *, radius=None, color=None, label=None, class_id=None, keypoint_id=None, timeless=False)</code>","text":"<p>Log a 2D or 3D point, with optional color.</p> <p>Logging again to the same <code>entity_path</code> will replace the previous point.</p> <ul> <li><code>position</code>: 2x1 or 3x1 array</li> <li><code>radius</code>: Optional radius (make it a sphere)</li> <li><code>color</code>: Optional color of the point</li> <li><code>label</code>: Optional text to show with the point</li> <li><code>class_id</code>: Optional class id for the point.     The class id provides color and label if not specified explicitly.</li> <li><code>keypoint_id</code>: Optional key point id for the point, identifying it within a class.     If keypoint_id is passed but no class_id was specified, class_id will be set to 0.     This is useful to identify points within a single classification (which is identified with class_id).     E.g. the classification might be 'Person' and the keypoints refer to joints on a detected skeleton.</li> </ul> <p>Colors should either be in 0-255 gamma space or in 0-1 linear space. Colors can be RGB or RGBA. You can supply no colors, one color, or one color per point in a Nx3 or Nx4 numpy array.</p> <p>Supported <code>dtype</code>s for <code>color</code>: * uint8: color components should be in 0-255 sRGB gamma space, except for alpha which should be in 0-255 linear space. * float32/float64: all color components should be in 0-1 linear space.</p>"},{"location":"common/primitives/#rerun.log_points","title":"<code>def rerun.log_points(entity_path, positions, *, identifiers=None, colors=None, radii=None, labels=None, class_ids=None, keypoint_ids=None, timeless=False)</code>","text":"<p>Log 2D or 3D points, with optional colors.</p> <p>Logging again to the same <code>entity_path</code> will replace all the previous points.</p> <ul> <li><code>positions</code>: Nx2 or Nx3 array</li> <li><code>identifiers</code>: per-point identifiers - unique names or numbers that show up when you hover the points.   In the future these will be used to track the points over time.</li> <li><code>color</code>: Optional colors of the points.</li> <li><code>labels</code>: Optional per-point text to show with the points</li> <li><code>class_ids</code>: Optional class ids for the points.     The class id provides colors and labels if not specified explicitly.</li> <li><code>keypoint_ids</code>: Optional key point ids for the points, identifying them within a class.     If keypoint_ids are passed in but no class_ids were specified, class_id will be set to 0.     This is useful to identify points within a single classification (which is identified with class_id).     E.g. the classification might be 'Person' and the keypoints refer to joints on a detected skeleton.</li> </ul> <p>Colors should either be in 0-255 gamma space or in 0-1 linear space. Colors can be RGB or RGBA. You can supply no colors, one color, or one color per point in a Nx3 or Nx4 numpy array.</p> <p>Supported <code>dtype</code>s for <code>colors</code>: * uint8: color components should be in 0-255 sRGB gamma space, except for alpha which should be in 0-255 linear space. * float32/float64: all color components should be in 0-1 linear space.</p>"},{"location":"common/primitives/#rerun.log_rect","title":"<code>def rerun.log_rect(entity_path, rect, *, rect_format=RectFormat.XYWH, color=None, label=None, class_id=None, timeless=False)</code>","text":"<p>Log a 2D rectangle.</p> <ul> <li><code>rect</code>: the recangle in [x, y, w, h], or some format you pick with the <code>rect_format</code> argument.</li> <li><code>rect_format</code>: how to interpret the <code>rect</code> argument</li> <li><code>color</code>: Optional RGB or RGBA triplet in 0-255 sRGB.</li> <li><code>label</code>: Optional text to show inside the rectangle.</li> <li><code>class_id</code>: Optional class id for the rectangle.    The class id provides color and label if not specified explicitly.</li> </ul>"},{"location":"common/primitives/#rerun.log_rects","title":"<code>def rerun.log_rects(entity_path, rects, *, rect_format=RectFormat.XYWH, identifiers=None, colors=None, labels=None, class_ids=None, timeless=False)</code>","text":"<p>Log multiple 2D rectangles.</p> <p>Logging again to the same <code>entity_path</code> will replace all the previous rectangles.</p> <ul> <li><code>rects</code>: Nx4 numpy array, where each row is [x, y, w, h], or some format you pick with the <code>rect_format</code> argument.</li> <li><code>rect_format</code>: how to interpret the <code>rect</code> argument</li> <li><code>identifiers</code>: per-point identifiers - unique names or numbers that show up when you hover the rectangles.   In the future these will be used to track the rectangles over time.</li> <li><code>labels</code>: Optional per-rectangle text to show inside the rectangle.</li> <li><code>class_ids</code>: Optional class ids for the rectangles.   The class id provides colors and labels if not specified explicitly.</li> </ul> <p>Colors should either be in 0-255 gamma space or in 0-1 linear space. Colors can be RGB or RGBA. You can supply no colors, one color, or one color per point in a Nx3 or Nx4 numpy array.</p> <p>Supported <code>dtype</code>s for <code>colors</code>: * uint8: color components should be in 0-255 sRGB gamma space, except for alpha which should be in 0-255 linear space. * float32/float64: all color components should be in 0-1 linear space.</p>"},{"location":"common/primitives/#rerun.log_obb","title":"<code>def rerun.log_obb(entity_path, half_size, position=None, rotation_q=None, color=None, stroke_width=None, label=None, class_id=None, timeless=False)</code>","text":"<p>Log a 3D oriented bounding box, defined by its half size.</p> <p><code>half_size</code>: Array with [x, y, z] half dimensions of the OBB. <code>position</code>: Array with [x, y, z] position of the OBB in world space. <code>rotation_q</code>: Array with quaternion coordinates [x, y, z, w] for the rotation from model to world space <code>color</code>: Optional RGB or RGBA triplet in 0-255 sRGB. <code>stroke_width</code>: Optional width of the OBB edges. <code>label</code> Optional text label placed at <code>position</code>. <code>class_id</code>: Optional class id for the OBB.              The class id provides colors and labels if not specified explicitly.</p>"},{"location":"common/primitives/#rerun.log_path","title":"<code>def rerun.log_path(entity_path, positions, *, stroke_width=None, color=None, timeless=False)</code>","text":"<p>Log a 3D path.</p> <p>A path is a list of points connected by line segments. It can be used to draw approximations of smooth curves.</p> <p>The points will be connected in order, like so:</p> <pre><code>   2------3     5\n  /        \\   /\n</code></pre> <p>0----1          \\ /                  4</p> <p><code>positions</code>: a Nx3 array of points along the path. <code>stroke_width</code>: width of the line. <code>color</code> is optional RGB or RGBA triplet in 0-255 sRGB.</p>"},{"location":"common/primitives/#rerun.log_line_segments","title":"<code>def rerun.log_line_segments(entity_path, positions, *, stroke_width=None, color=None, timeless=False)</code>","text":"<p>Log many 2D or 3D line segments.</p> <p>The points will be connected in even-odd pairs, like so:</p> <pre><code>   2------3     5\n               /\n</code></pre> <p>0----1            /                  4</p> <p><code>positions</code>: a Nx3 array of points along the path. <code>stroke_width</code>: width of the line. <code>color</code> is optional RGB or RGBA triplet in 0-255 sRGB.</p>"},{"location":"common/primitives/#rerun.log_arrow","title":"<code>def rerun.log_arrow(entity_path, origin, vector=None, *, color=None, label=None, width_scale=None, timeless=False)</code>","text":"<p>Log a 3D arrow.</p> <p>An arrow is defined with an <code>origin</code>, and a <code>vector</code>. This can also be considered as <code>start</code> and <code>end</code> positions for the arrow.</p> <p>The shaft is rendered as a cylinder with <code>radius = 0.5 * width_scale</code>. The tip is rendered as a cone with <code>height = 2.0 * width_scale</code> and <code>radius = 1.0 * width_scale</code>.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>The path to store the entity at.</p> required <code>origin</code> <code>Optional[npt.ArrayLike]</code> <p>The base position of the arrow.</p> required <code>vector</code> <code>Optional[npt.ArrayLike]</code> <p>The vector along which the arrow will be drawn.</p> <code>None</code> <code>color</code> <code>Optional[Sequence[int]]</code> <p>An optional RGB or RGBA triplet in 0-255 sRGB.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>An optional text to show beside the arrow.</p> <code>None</code> <code>width_scale</code> <code>Optional[float]</code> <p>An optional scaling factor, default=1.0.</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>The entity is not time-dependent, and will be visible at any time point.</p> <code>False</code>"},{"location":"common/transforms/","title":"Transforms","text":""},{"location":"common/transforms/#rerun.log_rigid3","title":"<code>def rerun.log_rigid3(entity_path, *, parent_from_child=None, child_from_parent=None, xyz='', timeless=False)</code>","text":"<p>Log a proper rigid 3D transform between this entity and the parent.</p> <p>Set either <code>parent_from_child</code> or <code>child_from_parent</code> to a tuple of <code>(translation_xyz, quat_xyzw)</code>.</p>"},{"location":"common/transforms/#rerun.log_rigid3--parent_from_child","title":"<code>parent_from_child</code>","text":"<p><code>parent_from_child=(translation_xyz, quat_xyzw)</code></p> <p>Also known as pose (e.g. camera extrinsics).</p> <p>The translation is the position of the entity in the parent space. The resulting transform from child to parent corresponds to taking a point in the child space, rotating it by the given rotations, and then translating it by the given translation:</p> <p>`point_parent = translation + quat * point_child * quat*</p>"},{"location":"common/transforms/#rerun.log_rigid3--child_from_parent","title":"<code>child_from_parent</code>","text":"<p><code>child_from_parent=(translation_xyz, quat_xyzw)</code></p> <p>the inverse of <code>parent_from_child</code></p>"},{"location":"common/transforms/#rerun.log_rigid3--xyz","title":"<code>xyz</code>","text":"<p>Optionally set the view coordinates of this entity, e.g. to <code>RDF</code> for <code>X=Right, Y=Down, Z=Forward</code>. This is a convenience for also calling <code>log_view_coordinates</code>.</p>"},{"location":"common/transforms/#rerun.log_rigid3--example","title":"Example","text":"<pre><code>rerun.log_rigid3(\"world/camera\", parent_from_child=(t,q))\nrerun.log_pinhole(\"world/camera/image\", \u2026)\n</code></pre>"},{"location":"common/transforms/#rerun.log_pinhole","title":"<code>def rerun.log_pinhole(entity_path, *, child_from_parent, width, height, timeless=False)</code>","text":"<p>Log a perspective camera model.</p> <p>This logs the pinhole model that projects points from the parent (camera) space to this space (image) such that:</p> <pre><code>point_image_hom = child_from_parent * point_cam\npoint_image = point_image_hom[:,1] / point_image_hom[2]\n</code></pre> <p>Where <code>point_image_hom</code> is the projected point in the image space expressed in homogeneous coordinates.</p>"},{"location":"common/transforms/#rerun.log_pinhole--example","title":"Example","text":"<pre><code>rerun.log_rigid3(\"world/camera\", \u2026)\nrerun.log_pinhole(\"world/camera/image\", \u2026)\n</code></pre> <p><code>child_from_parent</code>: Row-major intrinsics matrix for projecting from camera space to image space <code>resolution</code>: Array with [width, height] image resolution in pixels.</p>"},{"location":"common/transforms/#rerun.log_unknown_transform","title":"<code>def rerun.log_unknown_transform(entity_path, timeless=False)</code>","text":"<p>Log that this entity is NOT in the same space as the parent, but you do not (yet) know how they relate.</p>"},{"location":"common/transforms/#rerun.log_view_coordinates","title":"<code>def rerun.log_view_coordinates(entity_path, *, xyz='', up='', right_handed=None, timeless=False)</code>","text":"<p>Log the view coordinates for an entity.</p> <p>Each entity defines its own coordinate system, called a space. By logging view coordinates you can give semantic meaning to the XYZ axes of the space. This is for instance useful for camera entities (\"what axis is forward?\").</p> <p>For full control, set the <code>xyz</code> parameter to a three-letter acronym (<code>xyz=\"RDF\"</code>). Each letter represents:</p> <ul> <li>R: Right</li> <li>L: Left</li> <li>U: Up</li> <li>D: Down</li> <li>F: Forward</li> <li>B: Back</li> </ul> <p>Some of the most common are:</p> <ul> <li>\"RDF\": X=Right Y=Down Z=Forward  (right-handed)</li> <li>\"RUB\"  X=Right Y=Up   Z=Back     (right-handed)</li> <li>\"RDB\": X=Right Y=Down Z=Back     (left-handed)</li> <li>\"RUF\": X=Right Y=Up   Z=Forward  (left-handed)</li> </ul>"},{"location":"common/transforms/#rerun.log_view_coordinates--example","title":"Example","text":"<pre><code>rerun.log_view_coordinates(\"world/camera\", xyz=\"RUB\")\n</code></pre> <p>For world-coordinates it's often conventient to just specify an up-axis. You can do so by using the <code>up</code>-parameter (where <code>up</code> is one of \"+X\", \"-X\", \"+Y\", \"-Y\", \"+Z\", \"-Z\"):</p> <pre><code>rerun.log_view_coordinates(\"world\", up=\"+Z\", right_handed=True, timeless=True)\nrerun.log_view_coordinates(\"world\", up=\"-Y\", right_handed=False, timeless=True)\n</code></pre>"},{"location":"package/","title":"Full Package","text":"<ul> <li>rerun: Top-level User-facing APIs. See also: Common APIs<ul> <li>rerun.log: APIs for logging data</li> <li>rerun.color_conversion: Conversion utilities related to colors</li> <li>rerun.components: Helpers for constructing arrow components</li> </ul> </li> </ul>"},{"location":"package/rerun/__init__/","title":"__init__.py","text":""},{"location":"package/rerun/__init__/#rerun","title":"<code>rerun</code>","text":"<p>The Rerun Python SDK, which is a wrapper around the rerun_sdk crate.</p>"},{"location":"package/rerun/__init__/#rerun.log_pinhole","title":"<code>def log_pinhole(entity_path, *, child_from_parent, width, height, timeless=False)</code>","text":"<p>Log a perspective camera model.</p> <p>This logs the pinhole model that projects points from the parent (camera) space to this space (image) such that:</p> <pre><code>point_image_hom = child_from_parent * point_cam\npoint_image = point_image_hom[:,1] / point_image_hom[2]\n</code></pre> <p>Where <code>point_image_hom</code> is the projected point in the image space expressed in homogeneous coordinates.</p>"},{"location":"package/rerun/__init__/#rerun.log_pinhole--example","title":"Example","text":"<pre><code>rerun.log_rigid3(\"world/camera\", \u2026)\nrerun.log_pinhole(\"world/camera/image\", \u2026)\n</code></pre> <p><code>child_from_parent</code>: Row-major intrinsics matrix for projecting from camera space to image space <code>resolution</code>: Array with [width, height] image resolution in pixels.</p>"},{"location":"package/rerun/__init__/#rerun.log_view_coordinates","title":"<code>def log_view_coordinates(entity_path, *, xyz='', up='', right_handed=None, timeless=False)</code>","text":"<p>Log the view coordinates for an entity.</p> <p>Each entity defines its own coordinate system, called a space. By logging view coordinates you can give semantic meaning to the XYZ axes of the space. This is for instance useful for camera entities (\"what axis is forward?\").</p> <p>For full control, set the <code>xyz</code> parameter to a three-letter acronym (<code>xyz=\"RDF\"</code>). Each letter represents:</p> <ul> <li>R: Right</li> <li>L: Left</li> <li>U: Up</li> <li>D: Down</li> <li>F: Forward</li> <li>B: Back</li> </ul> <p>Some of the most common are:</p> <ul> <li>\"RDF\": X=Right Y=Down Z=Forward  (right-handed)</li> <li>\"RUB\"  X=Right Y=Up   Z=Back     (right-handed)</li> <li>\"RDB\": X=Right Y=Down Z=Back     (left-handed)</li> <li>\"RUF\": X=Right Y=Up   Z=Forward  (left-handed)</li> </ul>"},{"location":"package/rerun/__init__/#rerun.log_view_coordinates--example","title":"Example","text":"<pre><code>rerun.log_view_coordinates(\"world/camera\", xyz=\"RUB\")\n</code></pre> <p>For world-coordinates it's often conventient to just specify an up-axis. You can do so by using the <code>up</code>-parameter (where <code>up</code> is one of \"+X\", \"-X\", \"+Y\", \"-Y\", \"+Z\", \"-Z\"):</p> <pre><code>rerun.log_view_coordinates(\"world\", up=\"+Z\", right_handed=True, timeless=True)\nrerun.log_view_coordinates(\"world\", up=\"-Y\", right_handed=False, timeless=True)\n</code></pre>"},{"location":"package/rerun/__init__/#rerun.log_image","title":"<code>def log_image(entity_path, image, *, timeless=False)</code>","text":"<p>Log a gray or color image.</p> <p>The image should either have 1, 3 or 4 channels (gray, RGB or RGBA).</p> <p>Supported <code>dtype</code>s: * uint8: color components should be in 0-255 sRGB gamma space, except for alpha which should be in 0-255 linear space. * uint16: color components should be in 0-65535 sRGB gamma space, except for alpha which should be in 0-65535 linear space. * float32/float64: all color components should be in 0-1 linear space.</p>"},{"location":"package/rerun/__init__/#rerun.log_scalar","title":"<code>def log_scalar(entity_path, scalar, label=None, color=None, radius=None, scattered=None)</code>","text":"<p>Log a double-precision scalar that will be visualized as a timeseries plot.</p> <p>The current simulation time will be used for the time/X-axis, hence scalars cannot be timeless!</p> <p>See also examples/plots.</p>"},{"location":"package/rerun/__init__/#rerun.log_scalar--understanding-the-plot-and-attributes-hierarchy","title":"Understanding the plot and attributes hierarchy","text":"<p>Timeseries come in three parts: points, lines and finally the plots themselves. As a user of the Rerun SDK, your one and only entrypoint into that hierarchy is through the lowest-level layer: the points.</p> <p>When logging scalars and their attributes (label, color, radius, scattered) through this function, Rerun will turn them into points with similar attributes. From these points, lines with appropriate attributes can then be inferred; and from these inferred lines, plots with appropriate attributes will be inferred in turn!</p> <p>In terms of actual hierarchy: - Each space represents a single plot. - Each entity path within a space that contains scalar data is a line within that plot. - Each logged scalar is a point.</p> <p>E.g. the following:</p> <pre><code>rerun.log_scalar(\"trig/sin\", sin(t), label=\"sin(t)\", color=RED)\nrerun.log_scalar(\"trig/cos\", cos(t), label=\"cos(t)\", color=BLUE)\n</code></pre> <p>will yield a single plot (space = <code>trig</code>), comprised of two lines (entity paths <code>trig/sin</code> and <code>trig/cos</code>).</p>"},{"location":"package/rerun/__init__/#rerun.log_scalar--attributes","title":"Attributes","text":"<p>The attributes you assigned (or not) to a scalar will affect all layers: points, lines and plots alike.</p>"},{"location":"package/rerun/__init__/#rerun.log_scalar--label","title":"<code>label</code>","text":"<p>An optional label for the point.</p> <p>This won't show up on points at the moment, as our plots don't yet support displaying labels for individual points.</p> <p>If all points within a single entity path (i.e. a line) share the same label, then this label will be used as the label for the line itself. Otherwise, the line will be named after the entity path.</p> <p>The plot itself is named after the space it's in.</p>"},{"location":"package/rerun/__init__/#rerun.log_scalar--color","title":"<code>color</code>","text":"<p>An optional color in the form of a RGB or RGBA triplet in 0-255 sRGB. If left unspecified, a pseudo-random color will be used instead. That same color will apply to all points residing in the same entity path that don't have a color specified.</p> <p>Points within a single line do not have to share the same color, the line will have differently colored segments as appropriate.</p> <p>If all points within a single entity path (i.e. a line) share the same color, then this color will be used as the line color in the plot legend. Otherwise, the line will appear grey in the legend.</p>"},{"location":"package/rerun/__init__/#rerun.log_scalar--radius","title":"<code>radius</code>","text":"<p>An optional radius for the point.</p> <p>Points within a single line do not have to share the same radius, the line will have differently sized segments as appropriate.</p> <p>If all points within a single entity path (i.e. a line) share the same radius, then this radius will be used as the line width too. Otherwise, the line will use the default width of <code>1.0</code>.</p>"},{"location":"package/rerun/__init__/#rerun.log_scalar--scattered","title":"<code>scattered</code>","text":"<p>Specifies whether the point should form a continuous line with its neighbours, or whether it should stand on its own, akin to a scatter plot.</p> <p>Points within a single line do not have to all share the same scatteredness: the line will switch between a scattered and a continous representation as required.</p>"},{"location":"package/rerun/__init__/#rerun.log_arrow","title":"<code>def log_arrow(entity_path, origin, vector=None, *, color=None, label=None, width_scale=None, timeless=False)</code>","text":"<p>Log a 3D arrow.</p> <p>An arrow is defined with an <code>origin</code>, and a <code>vector</code>. This can also be considered as <code>start</code> and <code>end</code> positions for the arrow.</p> <p>The shaft is rendered as a cylinder with <code>radius = 0.5 * width_scale</code>. The tip is rendered as a cone with <code>height = 2.0 * width_scale</code> and <code>radius = 1.0 * width_scale</code>.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>The path to store the entity at.</p> required <code>origin</code> <code>Optional[npt.ArrayLike]</code> <p>The base position of the arrow.</p> required <code>vector</code> <code>Optional[npt.ArrayLike]</code> <p>The vector along which the arrow will be drawn.</p> <code>None</code> <code>color</code> <code>Optional[Sequence[int]]</code> <p>An optional RGB or RGBA triplet in 0-255 sRGB.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>An optional text to show beside the arrow.</p> <code>None</code> <code>width_scale</code> <code>Optional[float]</code> <p>An optional scaling factor, default=1.0.</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>The entity is not time-dependent, and will be visible at any time point.</p> <code>False</code>"},{"location":"package/rerun/__init__/#rerun.log_path","title":"<code>def log_path(entity_path, positions, *, stroke_width=None, color=None, timeless=False)</code>","text":"<p>Log a 3D path.</p> <p>A path is a list of points connected by line segments. It can be used to draw approximations of smooth curves.</p> <p>The points will be connected in order, like so:</p> <pre><code>   2------3     5\n  /        \\   /\n</code></pre> <p>0----1          \\ /                  4</p> <p><code>positions</code>: a Nx3 array of points along the path. <code>stroke_width</code>: width of the line. <code>color</code> is optional RGB or RGBA triplet in 0-255 sRGB.</p>"},{"location":"package/rerun/__init__/#rerun.log_obb","title":"<code>def log_obb(entity_path, half_size, position=None, rotation_q=None, color=None, stroke_width=None, label=None, class_id=None, timeless=False)</code>","text":"<p>Log a 3D oriented bounding box, defined by its half size.</p> <p><code>half_size</code>: Array with [x, y, z] half dimensions of the OBB. <code>position</code>: Array with [x, y, z] position of the OBB in world space. <code>rotation_q</code>: Array with quaternion coordinates [x, y, z, w] for the rotation from model to world space <code>color</code>: Optional RGB or RGBA triplet in 0-255 sRGB. <code>stroke_width</code>: Optional width of the OBB edges. <code>label</code> Optional text label placed at <code>position</code>. <code>class_id</code>: Optional class id for the OBB.              The class id provides colors and labels if not specified explicitly.</p>"},{"location":"package/rerun/__init__/#rerun.log_rect","title":"<code>def log_rect(entity_path, rect, *, rect_format=RectFormat.XYWH, color=None, label=None, class_id=None, timeless=False)</code>","text":"<p>Log a 2D rectangle.</p> <ul> <li><code>rect</code>: the recangle in [x, y, w, h], or some format you pick with the <code>rect_format</code> argument.</li> <li><code>rect_format</code>: how to interpret the <code>rect</code> argument</li> <li><code>color</code>: Optional RGB or RGBA triplet in 0-255 sRGB.</li> <li><code>label</code>: Optional text to show inside the rectangle.</li> <li><code>class_id</code>: Optional class id for the rectangle.    The class id provides color and label if not specified explicitly.</li> </ul>"},{"location":"package/rerun/__init__/#rerun.log_point","title":"<code>def log_point(entity_path, position, *, radius=None, color=None, label=None, class_id=None, keypoint_id=None, timeless=False)</code>","text":"<p>Log a 2D or 3D point, with optional color.</p> <p>Logging again to the same <code>entity_path</code> will replace the previous point.</p> <ul> <li><code>position</code>: 2x1 or 3x1 array</li> <li><code>radius</code>: Optional radius (make it a sphere)</li> <li><code>color</code>: Optional color of the point</li> <li><code>label</code>: Optional text to show with the point</li> <li><code>class_id</code>: Optional class id for the point.     The class id provides color and label if not specified explicitly.</li> <li><code>keypoint_id</code>: Optional key point id for the point, identifying it within a class.     If keypoint_id is passed but no class_id was specified, class_id will be set to 0.     This is useful to identify points within a single classification (which is identified with class_id).     E.g. the classification might be 'Person' and the keypoints refer to joints on a detected skeleton.</li> </ul> <p>Colors should either be in 0-255 gamma space or in 0-1 linear space. Colors can be RGB or RGBA. You can supply no colors, one color, or one color per point in a Nx3 or Nx4 numpy array.</p> <p>Supported <code>dtype</code>s for <code>color</code>: * uint8: color components should be in 0-255 sRGB gamma space, except for alpha which should be in 0-255 linear space. * float32/float64: all color components should be in 0-1 linear space.</p>"},{"location":"package/rerun/__init__/#rerun.log_mesh_file","title":"<code>def log_mesh_file(entity_path, mesh_format, mesh_file, *, transform=None, timeless=False)</code>","text":"<p>Log the contents of a mesh file (.gltf, .glb, .obj, \u2026).</p> <p><code>transform</code> is an optional 3x4 affine transform matrix applied to the mesh.</p>"},{"location":"package/rerun/__init__/#rerun.log_mesh_file--example","title":"Example:","text":"<pre><code># Move mesh 10 units along the X axis.\ntransform=np.array([\n    [1, 0, 0, 10],\n    [0, 1, 0, 0],\n    [0, 0, 1, 0]])\n</code></pre>"},{"location":"package/rerun/__init__/#rerun.log_depth_image","title":"<code>def log_depth_image(entity_path, image, *, meter=None, timeless=False)</code>","text":"<p>Log a depth image.</p> <p>The image must be a 2D array. Supported <code>dtype</code>:s are: uint8, uint16, float32, float64</p> <p>meter: How long is a meter in the given dtype?        For instance: with uint16, perhaps meter=1000 which would mean        you have millimeter precision and a range of up to ~65 meters (2^16 / 1000).</p>"},{"location":"package/rerun/__init__/#rerun.log_line_segments","title":"<code>def log_line_segments(entity_path, positions, *, stroke_width=None, color=None, timeless=False)</code>","text":"<p>Log many 2D or 3D line segments.</p> <p>The points will be connected in even-odd pairs, like so:</p> <pre><code>   2------3     5\n               /\n</code></pre> <p>0----1            /                  4</p> <p><code>positions</code>: a Nx3 array of points along the path. <code>stroke_width</code>: width of the line. <code>color</code> is optional RGB or RGBA triplet in 0-255 sRGB.</p>"},{"location":"package/rerun/__init__/#rerun.log_annotation_context","title":"<code>def log_annotation_context(entity_path, class_descriptions, *, timeless=True)</code>","text":"<p>Log an annotation context made up of a collection of ClassDescriptions.</p> <p>Any entity needing to access the annotation context will find it by searching the path upward. If all entities share the same you can simply log it to the root (\"/\"), or if you want a per-entity ClassDescriptions log it to the same path as your entity.</p> <p>Each ClassDescription must include an annotation info with an id, which will be used for matching the class and may optionally include a label and color. Colors should either be in 0-255 gamma space or in 0-1 linear space. Colors can be RGB or RGBA.</p> <p>These can either be specified verbosely as:</p> <pre><code>[AnnotationInfo(id=23, label='foo', color=(255, 0, 0)), ...]\n</code></pre> <p>Or using short-hand tuples.</p> <pre><code>[(23, 'bar'), ...]\n</code></pre> <p>Unspecified colors will be filled in by the visualizer randomly.</p>"},{"location":"package/rerun/__init__/#rerun.get_recording_id","title":"<code>def get_recording_id()</code>","text":"<p>Get the recording ID that this process is logging to, as a UUIDv4.</p> <p>The default recording_id is based on <code>multiprocessing.current_process().authkey</code> which means that all processes spawned with <code>multiprocessing</code> will have the same default recording_id.</p> <p>If you are not using <code>multiprocessing</code> and still want several different Python processes to log to the same Rerun instance (and be part of the same recording), you will need to manually assign them all the same recording_id. Any random UUIDv4 will work, or copy the recording id for the parent process.</p>"},{"location":"package/rerun/__init__/#rerun.log_image_file","title":"<code>def log_image_file(entity_path, img_path, img_format=None, timeless=False)</code>","text":"<p>Log the contents of an image file (only JPEGs supported for now).</p> <p>If no <code>img_format</code> is specified, we will try and guess it.</p>"},{"location":"package/rerun/__init__/#rerun.log_rects","title":"<code>def log_rects(entity_path, rects, *, rect_format=RectFormat.XYWH, identifiers=None, colors=None, labels=None, class_ids=None, timeless=False)</code>","text":"<p>Log multiple 2D rectangles.</p> <p>Logging again to the same <code>entity_path</code> will replace all the previous rectangles.</p> <ul> <li><code>rects</code>: Nx4 numpy array, where each row is [x, y, w, h], or some format you pick with the <code>rect_format</code> argument.</li> <li><code>rect_format</code>: how to interpret the <code>rect</code> argument</li> <li><code>identifiers</code>: per-point identifiers - unique names or numbers that show up when you hover the rectangles.   In the future these will be used to track the rectangles over time.</li> <li><code>labels</code>: Optional per-rectangle text to show inside the rectangle.</li> <li><code>class_ids</code>: Optional class ids for the rectangles.   The class id provides colors and labels if not specified explicitly.</li> </ul> <p>Colors should either be in 0-255 gamma space or in 0-1 linear space. Colors can be RGB or RGBA. You can supply no colors, one color, or one color per point in a Nx3 or Nx4 numpy array.</p> <p>Supported <code>dtype</code>s for <code>colors</code>: * uint8: color components should be in 0-255 sRGB gamma space, except for alpha which should be in 0-255 linear space. * float32/float64: all color components should be in 0-1 linear space.</p>"},{"location":"package/rerun/__init__/#rerun.log_unknown_transform","title":"<code>def log_unknown_transform(entity_path, timeless=False)</code>","text":"<p>Log that this entity is NOT in the same space as the parent, but you do not (yet) know how they relate.</p>"},{"location":"package/rerun/__init__/#rerun.log_cleared","title":"<code>def log_cleared(entity_path, *, recursive=False)</code>","text":"<p>Indicate that an entity at a given path should no longer be displayed.</p> <p>If <code>recursive</code> is True this will also clear all sub-paths</p>"},{"location":"package/rerun/__init__/#rerun.log_rigid3","title":"<code>def log_rigid3(entity_path, *, parent_from_child=None, child_from_parent=None, xyz='', timeless=False)</code>","text":"<p>Log a proper rigid 3D transform between this entity and the parent.</p> <p>Set either <code>parent_from_child</code> or <code>child_from_parent</code> to a tuple of <code>(translation_xyz, quat_xyzw)</code>.</p>"},{"location":"package/rerun/__init__/#rerun.log_rigid3--parent_from_child","title":"<code>parent_from_child</code>","text":"<p><code>parent_from_child=(translation_xyz, quat_xyzw)</code></p> <p>Also known as pose (e.g. camera extrinsics).</p> <p>The translation is the position of the entity in the parent space. The resulting transform from child to parent corresponds to taking a point in the child space, rotating it by the given rotations, and then translating it by the given translation:</p> <p>`point_parent = translation + quat * point_child * quat*</p>"},{"location":"package/rerun/__init__/#rerun.log_rigid3--child_from_parent","title":"<code>child_from_parent</code>","text":"<p><code>child_from_parent=(translation_xyz, quat_xyzw)</code></p> <p>the inverse of <code>parent_from_child</code></p>"},{"location":"package/rerun/__init__/#rerun.log_rigid3--xyz","title":"<code>xyz</code>","text":"<p>Optionally set the view coordinates of this entity, e.g. to <code>RDF</code> for <code>X=Right, Y=Down, Z=Forward</code>. This is a convenience for also calling <code>log_view_coordinates</code>.</p>"},{"location":"package/rerun/__init__/#rerun.log_rigid3--example","title":"Example","text":"<pre><code>rerun.log_rigid3(\"world/camera\", parent_from_child=(t,q))\nrerun.log_pinhole(\"world/camera/image\", \u2026)\n</code></pre>"},{"location":"package/rerun/__init__/#rerun.set_recording_id","title":"<code>def set_recording_id(value)</code>","text":"<p>Set the recording ID that this process is logging to, as a UUIDv4.</p> <p>The default recording_id is based on <code>multiprocessing.current_process().authkey</code> which means that all processes spawned with <code>multiprocessing</code> will have the same default recording_id.</p> <p>If you are not using <code>multiprocessing</code> and still want several different Python processes to log to the same Rerun instance (and be part of the same recording), you will need to manually assign them all the same recording_id. Any random UUIDv4 will work, or copy the recording id for the parent process.</p>"},{"location":"package/rerun/__init__/#rerun.log_text_entry","title":"<code>def log_text_entry(entity_path, text, level=LogLevel.INFO, color=None, timeless=False)</code>","text":"<p>Log a text entry, with optional level.</p> <ul> <li>If no <code>level</code> is given, it will default to <code>LogLevel.INFO</code>.</li> <li><code>color</code> is optional RGB or RGBA triplet in 0-255 sRGB.</li> </ul>"},{"location":"package/rerun/__init__/#rerun.init","title":"<code>def init(application_id, spawn_and_connect=False)</code>","text":"<p>Initialize the Rerun SDK with a user-chosen application id (name).</p> <p>Parameters:</p> Name Type Description Default <code>application_id</code> <code>str</code> <p>Your Rerun recordings will be categorized by this application id, so try to pick a unique one for each application that uses the Rerun SDK.</p> <p>For instance, if you have one application doing object detection and another doing camera calibration, you could have <code>rerun.init(\"object_detector\")</code> and <code>rerun.init(\"calibrator\")</code>.</p> required <p>spawn_and_connect : bool     Spawn a Rerun Viewer and stream logging data to it.     Short for calling <code>spawn_and_connect</code> separately.     If you don't call this, log events will be buffered indefinitely until     you call either <code>connect</code>, <code>show</code>, or <code>save</code></p>"},{"location":"package/rerun/__init__/#rerun.log_points","title":"<code>def log_points(entity_path, positions, *, identifiers=None, colors=None, radii=None, labels=None, class_ids=None, keypoint_ids=None, timeless=False)</code>","text":"<p>Log 2D or 3D points, with optional colors.</p> <p>Logging again to the same <code>entity_path</code> will replace all the previous points.</p> <ul> <li><code>positions</code>: Nx2 or Nx3 array</li> <li><code>identifiers</code>: per-point identifiers - unique names or numbers that show up when you hover the points.   In the future these will be used to track the points over time.</li> <li><code>color</code>: Optional colors of the points.</li> <li><code>labels</code>: Optional per-point text to show with the points</li> <li><code>class_ids</code>: Optional class ids for the points.     The class id provides colors and labels if not specified explicitly.</li> <li><code>keypoint_ids</code>: Optional key point ids for the points, identifying them within a class.     If keypoint_ids are passed in but no class_ids were specified, class_id will be set to 0.     This is useful to identify points within a single classification (which is identified with class_id).     E.g. the classification might be 'Person' and the keypoints refer to joints on a detected skeleton.</li> </ul> <p>Colors should either be in 0-255 gamma space or in 0-1 linear space. Colors can be RGB or RGBA. You can supply no colors, one color, or one color per point in a Nx3 or Nx4 numpy array.</p> <p>Supported <code>dtype</code>s for <code>colors</code>: * uint8: color components should be in 0-255 sRGB gamma space, except for alpha which should be in 0-255 linear space. * float32/float64: all color components should be in 0-1 linear space.</p>"},{"location":"package/rerun/__init__/#rerun.log_segmentation_image","title":"<code>def log_segmentation_image(entity_path, image, *, timeless=False)</code>","text":"<p>Log an image made up of integer class-ids.</p> <p>The image should have 1 channel, i.e. be either <code>H x W</code> or <code>H x W x 1</code>.</p>"},{"location":"package/rerun/__init__/#rerun.spawn_and_connect","title":"<code>def spawn_and_connect(port=9876)</code>","text":"<p>Spawn a Rerun Viewer and stream logging data to it.</p> <p>This is often the easiest and best way to use Rerun. Just call this once at the start of your program.</p> <p>See also: rerun.connect</p>"},{"location":"package/rerun/__init__/#rerun.connect","title":"<code>def connect(addr=None)</code>","text":"<p>Connect to a remote Rerun Viewer on the given ip:port.</p> <p>Requires that you first start a Rerun Viewer, e.g. with 'python -m rerun'</p>"},{"location":"package/rerun/__init__/#rerun.spawn_viewer","title":"<code>def spawn_viewer(port=9876)</code>","text":"<p>Spawn a Rerun Viewer, listening on the given port.</p>"},{"location":"package/rerun/__init__/#rerun.serve","title":"<code>def serve()</code>","text":"<p>Serve a Rerun Web Viewer.</p> <p>WARNING: This is an experimental feature.</p>"},{"location":"package/rerun/__init__/#rerun.disconnect","title":"<code>def disconnect()</code>","text":"<p>Disconnect from the remote rerun server (if any).</p>"},{"location":"package/rerun/__init__/#rerun.show","title":"<code>def show()</code>","text":"<p>Show previously logged data.</p> <p>This only works if you have not called <code>connect</code>.</p> <p>This will clear the logged data after showing it.</p> <p>NOTE: There is a bug which causes this function to only work once on some platforms.</p>"},{"location":"package/rerun/__init__/#rerun.save","title":"<code>def save(path)</code>","text":"<p>Save previously logged data to a file.</p> <p>This only works if you have not called <code>connect</code>.</p> <p>This will clear the logged data after saving.</p>"},{"location":"package/rerun/__init__/#rerun.set_time_sequence","title":"<code>def set_time_sequence(timeline, sequence)</code>","text":"<p>Set the current time for this thread.</p> <p>Used for all subsequent logging on the same thread, until the next call to <code>set_time_sequence</code>.</p> <p>For instance: <code>set_time_sequence(\"frame_nr\", frame_nr)</code>.</p> <p>You can remove a timeline again using <code>set_time_sequence(\"frame_nr\", None)</code>.</p> <p>There is no requirement of monoticity. You can move the time backwards if you like.</p>"},{"location":"package/rerun/__init__/#rerun.set_time_seconds","title":"<code>def set_time_seconds(timeline, seconds)</code>","text":"<p>Set the current time for this thread.</p> <p>Used for all subsequent logging on the same thread, until the next call to <code>set_time_seconds</code>.</p> <p>For instance: <code>set_time_seconds(\"capture_time\", seconds_since_unix_epoch)</code>.</p> <p>You can remove a timeline again using <code>set_time_seconds(\"capture_time\", None)</code>.</p> <p>The argument should be in seconds, and should be measured either from the unix epoch (1970-01-01), or from some recent time (e.g. your program startup).</p> <p>The bindings has a built-in time which is <code>log_time</code>, and is logged as seconds since unix epoch.</p> <p>There is no requirement of monoticity. You can move the time backwards if you like.</p>"},{"location":"package/rerun/__init__/#rerun.set_time_nanos","title":"<code>def set_time_nanos(timeline, nanos)</code>","text":"<p>Set the current time for this thread.</p> <p>Used for all subsequent logging on the same thread, until the next call to <code>set_time_nanos</code>.</p> <p>For instance: <code>set_time_nanos(\"capture_time\", nanos_since_unix_epoch)</code>.</p> <p>You can remove a timeline again using <code>set_time_nanos(\"capture_time\", None)</code>.</p> <p>The argument should be in nanoseconds, and should be measured either from the unix epoch (1970-01-01), or from some recent time (e.g. your program startup).</p> <p>The bindings has a built-in time which is <code>log_time</code>, and is logged as nanos since unix epoch.</p> <p>There is no requirement of monoticity. You can move the time backwards if you like.</p>"},{"location":"package/rerun/color_conversion/","title":"color_conversion.py","text":""},{"location":"package/rerun/color_conversion/#rerun.color_conversion","title":"<code>rerun.color_conversion</code>","text":"<p>Color conversion utilities.</p>"},{"location":"package/rerun/color_conversion/#rerun.color_conversion.u8_array_to_rgba","title":"<code>def u8_array_to_rgba(arr)</code>","text":"<p>Convert an array[4] of uint8 values into a uint32.</p>"},{"location":"package/rerun/color_conversion/#rerun.color_conversion.linear_to_gamma_u8_value","title":"<code>def linear_to_gamma_u8_value(linear)</code>","text":"<p>Transform color values from linear [0, 1] to gamma encoded [0, 255].</p> <p>Linear colors are expected to have dtype np.float32 or np.float64.</p> <p>Intended to implement the following per color value:</p> <pre><code>if l &lt;= 0.0 {\n    0\n} else if l &lt;= 0.0031308 {\n    round(3294.6 * l)\n} else if l &lt;= 1.0 {\n    round(269.025 * l.powf(1.0 / 2.4) - 14.025)\n} else {\n    255\n}\n</code></pre>"},{"location":"package/rerun/color_conversion/#rerun.color_conversion.linear_to_gamma_u8_pixel","title":"<code>def linear_to_gamma_u8_pixel(linear)</code>","text":"<p>Transform color pixels from linear [0, 1] to gamma encoded [0, 255].</p> <p>Linear colors are expected to have dtype np.float32 or np.float64.</p> <p>The last dimension of the colors array <code>linear</code> is expected to represent a single pixel color. - 3 colors means RGB - 4 colors means RGBA</p>"},{"location":"package/rerun/components/__init__/","title":"__init__.py","text":""},{"location":"package/rerun/components/__init__/#rerun.components","title":"<code>rerun.components</code>","text":"<p>The components package defines Python wrapper types for common registered Rerun components.</p>"},{"location":"package/rerun/components/__init__/#rerun.components.ComponentTypeFactory","title":"<code>def ComponentTypeFactory(name, array_cls, field)</code>","text":"<p>Build a component type wrapper.</p>"},{"location":"package/rerun/components/__init__/#rerun.components.build_dense_union","title":"<code>def build_dense_union(data_type, discriminant, child)</code>","text":"<p>Build a dense UnionArray given the <code>data_type</code>, a discriminant, and the child value array.</p> <p>If the discriminant string doesn't match any possible value, a <code>ValueError</code> is raised.</p>"},{"location":"package/rerun/components/annotation/","title":"annotation.py","text":""},{"location":"package/rerun/components/annotation/#rerun.components.annotation","title":"<code>rerun.components.annotation</code>","text":""},{"location":"package/rerun/components/annotation/#rerun.components.annotation.ClassIdArray","title":"<code>ClassIdArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/annotation/#rerun.components.annotation.ClassIdArray.from_numpy","title":"<code>def from_numpy(array)</code>","text":"<p>Build a <code>ClassIdArray</code> from an Nx1 numpy array.</p>"},{"location":"package/rerun/components/annotation/#rerun.components.annotation.KeypointIdArray","title":"<code>KeypointIdArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/annotation/#rerun.components.annotation.KeypointIdArray.from_numpy","title":"<code>def from_numpy(array)</code>","text":"<p>Build a <code>KeypointIdArray</code> from an Nx1 numpy array.</p>"},{"location":"package/rerun/components/arrow/","title":"arrow.py","text":""},{"location":"package/rerun/components/arrow/#rerun.components.arrow","title":"<code>rerun.components.arrow</code>","text":""},{"location":"package/rerun/components/arrow/#rerun.components.arrow.Arrow3DArray","title":"<code>Arrow3DArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/arrow/#rerun.components.arrow.Arrow3DArray.from_numpy","title":"<code>def from_numpy(origins, vectors)</code>","text":"<p>Build a <code>Arrow3DArray</code> from an Nx3 numpy array.</p>"},{"location":"package/rerun/components/box/","title":"box.py","text":""},{"location":"package/rerun/components/box/#rerun.components.box","title":"<code>rerun.components.box</code>","text":""},{"location":"package/rerun/components/box/#rerun.components.box.Box3DArray","title":"<code>Box3DArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/box/#rerun.components.box.Box3DArray.from_numpy","title":"<code>def from_numpy(array)</code>","text":"<p>Build a <code>Box3DArray</code> from an Nx3 numpy array.</p>"},{"location":"package/rerun/components/color/","title":"color.py","text":""},{"location":"package/rerun/components/color/#rerun.components.color","title":"<code>rerun.components.color</code>","text":""},{"location":"package/rerun/components/color/#rerun.components.color.ColorRGBAArray","title":"<code>ColorRGBAArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/color/#rerun.components.color.ColorRGBAArray.from_numpy","title":"<code>def from_numpy(array)</code>","text":"<p>Build a <code>ColorRGBAArray</code> from an numpy array.</p>"},{"location":"package/rerun/components/instance/","title":"instance.py","text":""},{"location":"package/rerun/components/instance/#rerun.components.instance","title":"<code>rerun.components.instance</code>","text":""},{"location":"package/rerun/components/instance/#rerun.components.instance.InstanceArray","title":"<code>InstanceArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/instance/#rerun.components.instance.InstanceArray.from_numpy","title":"<code>def from_numpy(array)</code>","text":"<p>Build a <code>InstanceArray</code> from an numpy array.</p>"},{"location":"package/rerun/components/label/","title":"label.py","text":""},{"location":"package/rerun/components/label/#rerun.components.label","title":"<code>rerun.components.label</code>","text":""},{"location":"package/rerun/components/label/#rerun.components.label.LabelArray","title":"<code>LabelArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/label/#rerun.components.label.LabelArray.new","title":"<code>def new(labels)</code>","text":"<p>Build a <code>LabelArray</code> from a sequence of str.</p>"},{"location":"package/rerun/components/linestrip/","title":"linestrip.py","text":""},{"location":"package/rerun/components/linestrip/#rerun.components.linestrip","title":"<code>rerun.components.linestrip</code>","text":""},{"location":"package/rerun/components/linestrip/#rerun.components.linestrip.LineStrip2DArray","title":"<code>LineStrip2DArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/linestrip/#rerun.components.linestrip.LineStrip2DArray.from_numpy_arrays","title":"<code>def from_numpy_arrays(array)</code>","text":"<p>Build a <code>LineStrip2DArray</code> from an array of [Nx2 numpy array].</p>"},{"location":"package/rerun/components/linestrip/#rerun.components.linestrip.LineStrip3DArray","title":"<code>LineStrip3DArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/linestrip/#rerun.components.linestrip.LineStrip3DArray.from_numpy_arrays","title":"<code>def from_numpy_arrays(array)</code>","text":"<p>Build a <code>LineStrip3DArray</code> from an array of [Nx3 numpy array].</p>"},{"location":"package/rerun/components/point/","title":"point.py","text":""},{"location":"package/rerun/components/point/#rerun.components.point","title":"<code>rerun.components.point</code>","text":""},{"location":"package/rerun/components/point/#rerun.components.point.Point2DArray","title":"<code>Point2DArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/point/#rerun.components.point.Point2DArray.from_numpy","title":"<code>def from_numpy(array)</code>","text":"<p>Build a <code>Point2DArray</code> from an Nx2 numpy array.</p>"},{"location":"package/rerun/components/point/#rerun.components.point.Point3DArray","title":"<code>Point3DArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/point/#rerun.components.point.Point3DArray.from_numpy","title":"<code>def from_numpy(array)</code>","text":"<p>Build a <code>Point3DArray</code> from an Nx3 numpy array.</p>"},{"location":"package/rerun/components/quaternion/","title":"quaternion.py","text":""},{"location":"package/rerun/components/quaternion/#rerun.components.quaternion","title":"<code>rerun.components.quaternion</code>","text":""},{"location":"package/rerun/components/quaternion/#rerun.components.quaternion.QuaternionArray","title":"<code>QuaternionArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/quaternion/#rerun.components.quaternion.QuaternionArray.from_numpy","title":"<code>def from_numpy(array)</code>","text":"<p>Build a <code>QuaternionArray</code> from an Nx4 numpy array.</p>"},{"location":"package/rerun/components/radius/","title":"radius.py","text":""},{"location":"package/rerun/components/radius/#rerun.components.radius","title":"<code>rerun.components.radius</code>","text":""},{"location":"package/rerun/components/radius/#rerun.components.radius.RadiusArray","title":"<code>RadiusArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/radius/#rerun.components.radius.RadiusArray.from_numpy","title":"<code>def from_numpy(array)</code>","text":"<p>Build a <code>RadiusArray</code> from an numpy array.</p>"},{"location":"package/rerun/components/rect2d/","title":"rect2d.py","text":""},{"location":"package/rerun/components/rect2d/#rerun.components.rect2d","title":"<code>rerun.components.rect2d</code>","text":""},{"location":"package/rerun/components/rect2d/#rerun.components.rect2d.RectFormat","title":"<code>RectFormat</code>","text":"<p>         Bases: <code>Enum</code></p> <p>How to specify rectangles (axis-aligned bounding boxes).</p>"},{"location":"package/rerun/components/rect2d/#rerun.components.rect2d.RectFormat.XYWH","title":"<code>XYWH = 'XYWH'</code>  <code>class-attribute</code>","text":"<p>[x,y,w,h], with x,y = left,top.</p>"},{"location":"package/rerun/components/rect2d/#rerun.components.rect2d.RectFormat.YXHW","title":"<code>YXHW = 'YXHW'</code>  <code>class-attribute</code>","text":"<p>[y,x,h,w], with x,y = left,top.</p>"},{"location":"package/rerun/components/rect2d/#rerun.components.rect2d.RectFormat.XYXY","title":"<code>XYXY = 'XYXY'</code>  <code>class-attribute</code>","text":"<p>[x0, y0, x1, y1], with x0,y0 = left,top and x1,y1 = right,bottom.</p>"},{"location":"package/rerun/components/rect2d/#rerun.components.rect2d.RectFormat.YXYX","title":"<code>YXYX = 'YXYX'</code>  <code>class-attribute</code>","text":"<p>[y0, x0, y1, x1], with x0,y0 = left,top and x1,y1 = right,bottom.</p>"},{"location":"package/rerun/components/rect2d/#rerun.components.rect2d.RectFormat.XCYCWH","title":"<code>XCYCWH = 'XCYCWH'</code>  <code>class-attribute</code>","text":"<p>[x_center, y_center, width, height].</p>"},{"location":"package/rerun/components/rect2d/#rerun.components.rect2d.RectFormat.XCYCW2H2","title":"<code>XCYCW2H2 = 'XCYCW2H2'</code>  <code>class-attribute</code>","text":"<p>[x_center, y_center, width/2, height/2].</p>"},{"location":"package/rerun/components/rect2d/#rerun.components.rect2d.Rect2DArray","title":"<code>Rect2DArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/rect2d/#rerun.components.rect2d.Rect2DArray.from_numpy_and_format","title":"<code>def from_numpy_and_format(array, rect_format)</code>","text":"<p>Build a <code>Rect2DArray</code> from an Nx4 numpy array.</p>"},{"location":"package/rerun/components/scalar/","title":"scalar.py","text":""},{"location":"package/rerun/components/scalar/#rerun.components.scalar","title":"<code>rerun.components.scalar</code>","text":""},{"location":"package/rerun/components/scalar/#rerun.components.scalar.ScalarArray","title":"<code>ScalarArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/scalar/#rerun.components.scalar.ScalarArray.from_numpy","title":"<code>def from_numpy(array)</code>","text":"<p>Build a <code>ScalarArray</code> from an numpy array.</p>"},{"location":"package/rerun/components/scalar/#rerun.components.scalar.ScalarPlotPropsArray","title":"<code>ScalarPlotPropsArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/scalar/#rerun.components.scalar.ScalarPlotPropsArray.from_props","title":"<code>def from_props(props)</code>","text":"<p>Build a <code>ScalarPlotPropsArray</code> from an numpy array.</p>"},{"location":"package/rerun/components/tensor/","title":"tensor.py","text":""},{"location":"package/rerun/components/tensor/#rerun.components.tensor","title":"<code>rerun.components.tensor</code>","text":""},{"location":"package/rerun/components/tensor/#rerun.components.tensor.TensorArray","title":"<code>TensorArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/tensor/#rerun.components.tensor.TensorArray.from_numpy","title":"<code>def from_numpy(array, names=None, meaning=None, meter=None)</code>","text":"<p>Build a <code>TensorArray</code> from an numpy array.</p>"},{"location":"package/rerun/components/text_entry/","title":"text_entry.py","text":""},{"location":"package/rerun/components/text_entry/#rerun.components.text_entry","title":"<code>rerun.components.text_entry</code>","text":""},{"location":"package/rerun/components/text_entry/#rerun.components.text_entry.TextEntryArray","title":"<code>TextEntryArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/text_entry/#rerun.components.text_entry.TextEntryArray.from_bodies_and_levels","title":"<code>def from_bodies_and_levels(text_entries)</code>","text":"<p>Build a <code>TextEntryArray</code> from a sequence of text bodies and log levels.</p>"},{"location":"package/rerun/components/vec/","title":"vec.py","text":""},{"location":"package/rerun/components/vec/#rerun.components.vec","title":"<code>rerun.components.vec</code>","text":""},{"location":"package/rerun/components/vec/#rerun.components.vec.Vec2DArray","title":"<code>Vec2DArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/vec/#rerun.components.vec.Vec2DArray.from_numpy","title":"<code>def from_numpy(array)</code>","text":"<p>Build a <code>Vec2DArray</code> from an Nx2 numpy array.</p>"},{"location":"package/rerun/components/vec/#rerun.components.vec.Vec3DArray","title":"<code>Vec3DArray</code>","text":"<p>         Bases: <code>pa.ExtensionArray</code></p>"},{"location":"package/rerun/components/vec/#rerun.components.vec.Vec3DArray.from_numpy","title":"<code>def from_numpy(array)</code>","text":"<p>Build a <code>Vec3DArray</code> from an Nx3 numpy array.</p>"},{"location":"package/rerun/log/__init__/","title":"__init__.py","text":""},{"location":"package/rerun/log/__init__/#rerun.log","title":"<code>rerun.log</code>","text":""},{"location":"package/rerun/log/__init__/#rerun.log.log_cleared","title":"<code>def log_cleared(entity_path, *, recursive=False)</code>","text":"<p>Indicate that an entity at a given path should no longer be displayed.</p> <p>If <code>recursive</code> is True this will also clear all sub-paths</p>"},{"location":"package/rerun/log/__init__/#rerun.log.set_visible","title":"<code>def set_visible(entity_path, visibile)</code>","text":"<p>set_visible has been deprecated.</p> <p>The replacement is <code>log_cleared()</code>. See: https://github.com/rerun-io/rerun/pull/285 for details</p>"},{"location":"package/rerun/log/annotation/","title":"annotation.py","text":""},{"location":"package/rerun/log/annotation/#rerun.log.annotation","title":"<code>rerun.log.annotation</code>","text":""},{"location":"package/rerun/log/annotation/#rerun.log.annotation.AnnotationInfo","title":"<code>AnnotationInfo</code>  <code>dataclass</code>","text":"<p>Annotation info annotating a class id or key-point id.</p> <p>Color and label will be used to annotate entities/keypoints which reference the id. The id refers either to a class or key-point id</p>"},{"location":"package/rerun/log/annotation/#rerun.log.annotation.ClassDescription","title":"<code>ClassDescription</code>  <code>dataclass</code>","text":"<p>Metadata about a class type identified by an id.</p> <p>Typically a class description contains only a annotation info. However, within a class there might be several keypoints, each with its own annotation info. Keypoints in turn may be connected to each other by connections (typically used for skeleton edges).</p>"},{"location":"package/rerun/log/annotation/#rerun.log.annotation.log_annotation_context","title":"<code>def log_annotation_context(entity_path, class_descriptions, *, timeless=True)</code>","text":"<p>Log an annotation context made up of a collection of ClassDescriptions.</p> <p>Any entity needing to access the annotation context will find it by searching the path upward. If all entities share the same you can simply log it to the root (\"/\"), or if you want a per-entity ClassDescriptions log it to the same path as your entity.</p> <p>Each ClassDescription must include an annotation info with an id, which will be used for matching the class and may optionally include a label and color. Colors should either be in 0-255 gamma space or in 0-1 linear space. Colors can be RGB or RGBA.</p> <p>These can either be specified verbosely as:</p> <pre><code>[AnnotationInfo(id=23, label='foo', color=(255, 0, 0)), ...]\n</code></pre> <p>Or using short-hand tuples.</p> <pre><code>[(23, 'bar'), ...]\n</code></pre> <p>Unspecified colors will be filled in by the visualizer randomly.</p>"},{"location":"package/rerun/log/arrow/","title":"arrow.py","text":""},{"location":"package/rerun/log/arrow/#rerun.log.arrow","title":"<code>rerun.log.arrow</code>","text":""},{"location":"package/rerun/log/arrow/#rerun.log.arrow.log_arrow","title":"<code>def log_arrow(entity_path, origin, vector=None, *, color=None, label=None, width_scale=None, timeless=False)</code>","text":"<p>Log a 3D arrow.</p> <p>An arrow is defined with an <code>origin</code>, and a <code>vector</code>. This can also be considered as <code>start</code> and <code>end</code> positions for the arrow.</p> <p>The shaft is rendered as a cylinder with <code>radius = 0.5 * width_scale</code>. The tip is rendered as a cone with <code>height = 2.0 * width_scale</code> and <code>radius = 1.0 * width_scale</code>.</p> <p>Parameters:</p> Name Type Description Default <code>entity_path</code> <code>str</code> <p>The path to store the entity at.</p> required <code>origin</code> <code>Optional[npt.ArrayLike]</code> <p>The base position of the arrow.</p> required <code>vector</code> <code>Optional[npt.ArrayLike]</code> <p>The vector along which the arrow will be drawn.</p> <code>None</code> <code>color</code> <code>Optional[Sequence[int]]</code> <p>An optional RGB or RGBA triplet in 0-255 sRGB.</p> <code>None</code> <code>label</code> <code>Optional[str]</code> <p>An optional text to show beside the arrow.</p> <code>None</code> <code>width_scale</code> <code>Optional[float]</code> <p>An optional scaling factor, default=1.0.</p> <code>None</code> <code>timeless</code> <code>bool</code> <p>The entity is not time-dependent, and will be visible at any time point.</p> <code>False</code>"},{"location":"package/rerun/log/bounding_box/","title":"bounding_box.py","text":""},{"location":"package/rerun/log/bounding_box/#rerun.log.bounding_box","title":"<code>rerun.log.bounding_box</code>","text":""},{"location":"package/rerun/log/bounding_box/#rerun.log.bounding_box.log_obb","title":"<code>def log_obb(entity_path, half_size, position=None, rotation_q=None, color=None, stroke_width=None, label=None, class_id=None, timeless=False)</code>","text":"<p>Log a 3D oriented bounding box, defined by its half size.</p> <p><code>half_size</code>: Array with [x, y, z] half dimensions of the OBB. <code>position</code>: Array with [x, y, z] position of the OBB in world space. <code>rotation_q</code>: Array with quaternion coordinates [x, y, z, w] for the rotation from model to world space <code>color</code>: Optional RGB or RGBA triplet in 0-255 sRGB. <code>stroke_width</code>: Optional width of the OBB edges. <code>label</code> Optional text label placed at <code>position</code>. <code>class_id</code>: Optional class id for the OBB.              The class id provides colors and labels if not specified explicitly.</p>"},{"location":"package/rerun/log/camera/","title":"camera.py","text":""},{"location":"package/rerun/log/camera/#rerun.log.camera","title":"<code>rerun.log.camera</code>","text":""},{"location":"package/rerun/log/camera/#rerun.log.camera.log_pinhole","title":"<code>def log_pinhole(entity_path, *, child_from_parent, width, height, timeless=False)</code>","text":"<p>Log a perspective camera model.</p> <p>This logs the pinhole model that projects points from the parent (camera) space to this space (image) such that:</p> <pre><code>point_image_hom = child_from_parent * point_cam\npoint_image = point_image_hom[:,1] / point_image_hom[2]\n</code></pre> <p>Where <code>point_image_hom</code> is the projected point in the image space expressed in homogeneous coordinates.</p>"},{"location":"package/rerun/log/camera/#rerun.log.camera.log_pinhole--example","title":"Example","text":"<pre><code>rerun.log_rigid3(\"world/camera\", \u2026)\nrerun.log_pinhole(\"world/camera/image\", \u2026)\n</code></pre> <p><code>child_from_parent</code>: Row-major intrinsics matrix for projecting from camera space to image space <code>resolution</code>: Array with [width, height] image resolution in pixels.</p>"},{"location":"package/rerun/log/error_utils/","title":"error_utils.py","text":""},{"location":"package/rerun/log/error_utils/#rerun.log.error_utils","title":"<code>rerun.log.error_utils</code>","text":""},{"location":"package/rerun/log/file/","title":"file.py","text":""},{"location":"package/rerun/log/file/#rerun.log.file","title":"<code>rerun.log.file</code>","text":""},{"location":"package/rerun/log/file/#rerun.log.file.log_mesh_file","title":"<code>def log_mesh_file(entity_path, mesh_format, mesh_file, *, transform=None, timeless=False)</code>","text":"<p>Log the contents of a mesh file (.gltf, .glb, .obj, \u2026).</p> <p><code>transform</code> is an optional 3x4 affine transform matrix applied to the mesh.</p>"},{"location":"package/rerun/log/file/#rerun.log.file.log_mesh_file--example","title":"Example:","text":"<pre><code># Move mesh 10 units along the X axis.\ntransform=np.array([\n    [1, 0, 0, 10],\n    [0, 1, 0, 0],\n    [0, 0, 1, 0]])\n</code></pre>"},{"location":"package/rerun/log/file/#rerun.log.file.log_image_file","title":"<code>def log_image_file(entity_path, img_path, img_format=None, timeless=False)</code>","text":"<p>Log the contents of an image file (only JPEGs supported for now).</p> <p>If no <code>img_format</code> is specified, we will try and guess it.</p>"},{"location":"package/rerun/log/image/","title":"image.py","text":""},{"location":"package/rerun/log/image/#rerun.log.image","title":"<code>rerun.log.image</code>","text":""},{"location":"package/rerun/log/image/#rerun.log.image.log_image","title":"<code>def log_image(entity_path, image, *, timeless=False)</code>","text":"<p>Log a gray or color image.</p> <p>The image should either have 1, 3 or 4 channels (gray, RGB or RGBA).</p> <p>Supported <code>dtype</code>s: * uint8: color components should be in 0-255 sRGB gamma space, except for alpha which should be in 0-255 linear space. * uint16: color components should be in 0-65535 sRGB gamma space, except for alpha which should be in 0-65535 linear space. * float32/float64: all color components should be in 0-1 linear space.</p>"},{"location":"package/rerun/log/image/#rerun.log.image.log_depth_image","title":"<code>def log_depth_image(entity_path, image, *, meter=None, timeless=False)</code>","text":"<p>Log a depth image.</p> <p>The image must be a 2D array. Supported <code>dtype</code>:s are: uint8, uint16, float32, float64</p> <p>meter: How long is a meter in the given dtype?        For instance: with uint16, perhaps meter=1000 which would mean        you have millimeter precision and a range of up to ~65 meters (2^16 / 1000).</p>"},{"location":"package/rerun/log/image/#rerun.log.image.log_segmentation_image","title":"<code>def log_segmentation_image(entity_path, image, *, timeless=False)</code>","text":"<p>Log an image made up of integer class-ids.</p> <p>The image should have 1 channel, i.e. be either <code>H x W</code> or <code>H x W x 1</code>.</p>"},{"location":"package/rerun/log/lines/","title":"lines.py","text":""},{"location":"package/rerun/log/lines/#rerun.log.lines","title":"<code>rerun.log.lines</code>","text":""},{"location":"package/rerun/log/lines/#rerun.log.lines.log_path","title":"<code>def log_path(entity_path, positions, *, stroke_width=None, color=None, timeless=False)</code>","text":"<p>Log a 3D path.</p> <p>A path is a list of points connected by line segments. It can be used to draw approximations of smooth curves.</p> <p>The points will be connected in order, like so:</p> <pre><code>   2------3     5\n  /        \\   /\n</code></pre> <p>0----1          \\ /                  4</p> <p><code>positions</code>: a Nx3 array of points along the path. <code>stroke_width</code>: width of the line. <code>color</code> is optional RGB or RGBA triplet in 0-255 sRGB.</p>"},{"location":"package/rerun/log/lines/#rerun.log.lines.log_line_segments","title":"<code>def log_line_segments(entity_path, positions, *, stroke_width=None, color=None, timeless=False)</code>","text":"<p>Log many 2D or 3D line segments.</p> <p>The points will be connected in even-odd pairs, like so:</p> <pre><code>   2------3     5\n               /\n</code></pre> <p>0----1            /                  4</p> <p><code>positions</code>: a Nx3 array of points along the path. <code>stroke_width</code>: width of the line. <code>color</code> is optional RGB or RGBA triplet in 0-255 sRGB.</p>"},{"location":"package/rerun/log/points/","title":"points.py","text":""},{"location":"package/rerun/log/points/#rerun.log.points","title":"<code>rerun.log.points</code>","text":""},{"location":"package/rerun/log/points/#rerun.log.points.log_point","title":"<code>def log_point(entity_path, position, *, radius=None, color=None, label=None, class_id=None, keypoint_id=None, timeless=False)</code>","text":"<p>Log a 2D or 3D point, with optional color.</p> <p>Logging again to the same <code>entity_path</code> will replace the previous point.</p> <ul> <li><code>position</code>: 2x1 or 3x1 array</li> <li><code>radius</code>: Optional radius (make it a sphere)</li> <li><code>color</code>: Optional color of the point</li> <li><code>label</code>: Optional text to show with the point</li> <li><code>class_id</code>: Optional class id for the point.     The class id provides color and label if not specified explicitly.</li> <li><code>keypoint_id</code>: Optional key point id for the point, identifying it within a class.     If keypoint_id is passed but no class_id was specified, class_id will be set to 0.     This is useful to identify points within a single classification (which is identified with class_id).     E.g. the classification might be 'Person' and the keypoints refer to joints on a detected skeleton.</li> </ul> <p>Colors should either be in 0-255 gamma space or in 0-1 linear space. Colors can be RGB or RGBA. You can supply no colors, one color, or one color per point in a Nx3 or Nx4 numpy array.</p> <p>Supported <code>dtype</code>s for <code>color</code>: * uint8: color components should be in 0-255 sRGB gamma space, except for alpha which should be in 0-255 linear space. * float32/float64: all color components should be in 0-1 linear space.</p>"},{"location":"package/rerun/log/points/#rerun.log.points.log_points","title":"<code>def log_points(entity_path, positions, *, identifiers=None, colors=None, radii=None, labels=None, class_ids=None, keypoint_ids=None, timeless=False)</code>","text":"<p>Log 2D or 3D points, with optional colors.</p> <p>Logging again to the same <code>entity_path</code> will replace all the previous points.</p> <ul> <li><code>positions</code>: Nx2 or Nx3 array</li> <li><code>identifiers</code>: per-point identifiers - unique names or numbers that show up when you hover the points.   In the future these will be used to track the points over time.</li> <li><code>color</code>: Optional colors of the points.</li> <li><code>labels</code>: Optional per-point text to show with the points</li> <li><code>class_ids</code>: Optional class ids for the points.     The class id provides colors and labels if not specified explicitly.</li> <li><code>keypoint_ids</code>: Optional key point ids for the points, identifying them within a class.     If keypoint_ids are passed in but no class_ids were specified, class_id will be set to 0.     This is useful to identify points within a single classification (which is identified with class_id).     E.g. the classification might be 'Person' and the keypoints refer to joints on a detected skeleton.</li> </ul> <p>Colors should either be in 0-255 gamma space or in 0-1 linear space. Colors can be RGB or RGBA. You can supply no colors, one color, or one color per point in a Nx3 or Nx4 numpy array.</p> <p>Supported <code>dtype</code>s for <code>colors</code>: * uint8: color components should be in 0-255 sRGB gamma space, except for alpha which should be in 0-255 linear space. * float32/float64: all color components should be in 0-1 linear space.</p>"},{"location":"package/rerun/log/rects/","title":"rects.py","text":""},{"location":"package/rerun/log/rects/#rerun.log.rects","title":"<code>rerun.log.rects</code>","text":""},{"location":"package/rerun/log/rects/#rerun.log.rects.RectFormat","title":"<code>RectFormat</code>","text":"<p>         Bases: <code>Enum</code></p> <p>How to specify rectangles (axis-aligned bounding boxes).</p>"},{"location":"package/rerun/log/rects/#rerun.components.rect2d.RectFormat.XYWH","title":"<code>XYWH = 'XYWH'</code>  <code>class-attribute</code>","text":"<p>[x,y,w,h], with x,y = left,top.</p>"},{"location":"package/rerun/log/rects/#rerun.components.rect2d.RectFormat.YXHW","title":"<code>YXHW = 'YXHW'</code>  <code>class-attribute</code>","text":"<p>[y,x,h,w], with x,y = left,top.</p>"},{"location":"package/rerun/log/rects/#rerun.components.rect2d.RectFormat.XYXY","title":"<code>XYXY = 'XYXY'</code>  <code>class-attribute</code>","text":"<p>[x0, y0, x1, y1], with x0,y0 = left,top and x1,y1 = right,bottom.</p>"},{"location":"package/rerun/log/rects/#rerun.components.rect2d.RectFormat.YXYX","title":"<code>YXYX = 'YXYX'</code>  <code>class-attribute</code>","text":"<p>[y0, x0, y1, x1], with x0,y0 = left,top and x1,y1 = right,bottom.</p>"},{"location":"package/rerun/log/rects/#rerun.components.rect2d.RectFormat.XCYCWH","title":"<code>XCYCWH = 'XCYCWH'</code>  <code>class-attribute</code>","text":"<p>[x_center, y_center, width, height].</p>"},{"location":"package/rerun/log/rects/#rerun.components.rect2d.RectFormat.XCYCW2H2","title":"<code>XCYCW2H2 = 'XCYCW2H2'</code>  <code>class-attribute</code>","text":"<p>[x_center, y_center, width/2, height/2].</p>"},{"location":"package/rerun/log/rects/#rerun.log.rects.log_rect","title":"<code>def log_rect(entity_path, rect, *, rect_format=RectFormat.XYWH, color=None, label=None, class_id=None, timeless=False)</code>","text":"<p>Log a 2D rectangle.</p> <ul> <li><code>rect</code>: the recangle in [x, y, w, h], or some format you pick with the <code>rect_format</code> argument.</li> <li><code>rect_format</code>: how to interpret the <code>rect</code> argument</li> <li><code>color</code>: Optional RGB or RGBA triplet in 0-255 sRGB.</li> <li><code>label</code>: Optional text to show inside the rectangle.</li> <li><code>class_id</code>: Optional class id for the rectangle.    The class id provides color and label if not specified explicitly.</li> </ul>"},{"location":"package/rerun/log/rects/#rerun.log.rects.log_rects","title":"<code>def log_rects(entity_path, rects, *, rect_format=RectFormat.XYWH, identifiers=None, colors=None, labels=None, class_ids=None, timeless=False)</code>","text":"<p>Log multiple 2D rectangles.</p> <p>Logging again to the same <code>entity_path</code> will replace all the previous rectangles.</p> <ul> <li><code>rects</code>: Nx4 numpy array, where each row is [x, y, w, h], or some format you pick with the <code>rect_format</code> argument.</li> <li><code>rect_format</code>: how to interpret the <code>rect</code> argument</li> <li><code>identifiers</code>: per-point identifiers - unique names or numbers that show up when you hover the rectangles.   In the future these will be used to track the rectangles over time.</li> <li><code>labels</code>: Optional per-rectangle text to show inside the rectangle.</li> <li><code>class_ids</code>: Optional class ids for the rectangles.   The class id provides colors and labels if not specified explicitly.</li> </ul> <p>Colors should either be in 0-255 gamma space or in 0-1 linear space. Colors can be RGB or RGBA. You can supply no colors, one color, or one color per point in a Nx3 or Nx4 numpy array.</p> <p>Supported <code>dtype</code>s for <code>colors</code>: * uint8: color components should be in 0-255 sRGB gamma space, except for alpha which should be in 0-255 linear space. * float32/float64: all color components should be in 0-1 linear space.</p>"},{"location":"package/rerun/log/scalar/","title":"scalar.py","text":""},{"location":"package/rerun/log/scalar/#rerun.log.scalar","title":"<code>rerun.log.scalar</code>","text":""},{"location":"package/rerun/log/scalar/#rerun.log.scalar.log_scalar","title":"<code>def log_scalar(entity_path, scalar, label=None, color=None, radius=None, scattered=None)</code>","text":"<p>Log a double-precision scalar that will be visualized as a timeseries plot.</p> <p>The current simulation time will be used for the time/X-axis, hence scalars cannot be timeless!</p> <p>See also examples/plots.</p>"},{"location":"package/rerun/log/scalar/#rerun.log.scalar.log_scalar--understanding-the-plot-and-attributes-hierarchy","title":"Understanding the plot and attributes hierarchy","text":"<p>Timeseries come in three parts: points, lines and finally the plots themselves. As a user of the Rerun SDK, your one and only entrypoint into that hierarchy is through the lowest-level layer: the points.</p> <p>When logging scalars and their attributes (label, color, radius, scattered) through this function, Rerun will turn them into points with similar attributes. From these points, lines with appropriate attributes can then be inferred; and from these inferred lines, plots with appropriate attributes will be inferred in turn!</p> <p>In terms of actual hierarchy: - Each space represents a single plot. - Each entity path within a space that contains scalar data is a line within that plot. - Each logged scalar is a point.</p> <p>E.g. the following:</p> <pre><code>rerun.log_scalar(\"trig/sin\", sin(t), label=\"sin(t)\", color=RED)\nrerun.log_scalar(\"trig/cos\", cos(t), label=\"cos(t)\", color=BLUE)\n</code></pre> <p>will yield a single plot (space = <code>trig</code>), comprised of two lines (entity paths <code>trig/sin</code> and <code>trig/cos</code>).</p>"},{"location":"package/rerun/log/scalar/#rerun.log.scalar.log_scalar--attributes","title":"Attributes","text":"<p>The attributes you assigned (or not) to a scalar will affect all layers: points, lines and plots alike.</p>"},{"location":"package/rerun/log/scalar/#rerun.log.scalar.log_scalar--label","title":"<code>label</code>","text":"<p>An optional label for the point.</p> <p>This won't show up on points at the moment, as our plots don't yet support displaying labels for individual points.</p> <p>If all points within a single entity path (i.e. a line) share the same label, then this label will be used as the label for the line itself. Otherwise, the line will be named after the entity path.</p> <p>The plot itself is named after the space it's in.</p>"},{"location":"package/rerun/log/scalar/#rerun.log.scalar.log_scalar--color","title":"<code>color</code>","text":"<p>An optional color in the form of a RGB or RGBA triplet in 0-255 sRGB. If left unspecified, a pseudo-random color will be used instead. That same color will apply to all points residing in the same entity path that don't have a color specified.</p> <p>Points within a single line do not have to share the same color, the line will have differently colored segments as appropriate.</p> <p>If all points within a single entity path (i.e. a line) share the same color, then this color will be used as the line color in the plot legend. Otherwise, the line will appear grey in the legend.</p>"},{"location":"package/rerun/log/scalar/#rerun.log.scalar.log_scalar--radius","title":"<code>radius</code>","text":"<p>An optional radius for the point.</p> <p>Points within a single line do not have to share the same radius, the line will have differently sized segments as appropriate.</p> <p>If all points within a single entity path (i.e. a line) share the same radius, then this radius will be used as the line width too. Otherwise, the line will use the default width of <code>1.0</code>.</p>"},{"location":"package/rerun/log/scalar/#rerun.log.scalar.log_scalar--scattered","title":"<code>scattered</code>","text":"<p>Specifies whether the point should form a continuous line with its neighbours, or whether it should stand on its own, akin to a scatter plot.</p> <p>Points within a single line do not have to all share the same scatteredness: the line will switch between a scattered and a continous representation as required.</p>"},{"location":"package/rerun/log/tensor/","title":"tensor.py","text":""},{"location":"package/rerun/log/tensor/#rerun.log.tensor","title":"<code>rerun.log.tensor</code>","text":""},{"location":"package/rerun/log/tensor/#rerun.log.tensor.TorchTensorLike","title":"<code>TorchTensorLike</code>","text":"<p>         Bases: <code>Protocol</code></p> <p>Describes what is need from a Torch Tensor to be loggable to Rerun.</p>"},{"location":"package/rerun/log/text/","title":"text.py","text":""},{"location":"package/rerun/log/text/#rerun.log.text","title":"<code>rerun.log.text</code>","text":""},{"location":"package/rerun/log/text/#rerun.log.text.LogLevel","title":"<code>LogLevel</code>  <code>dataclass</code>","text":"<p>Represents the standard log levels.</p> <p>This is a collection of constants rather than an enum because we do support arbitrary strings as level (e.g. for user-defined levels).</p>"},{"location":"package/rerun/log/text/#rerun.log.text.LoggingHandler","title":"<code>LoggingHandler</code>","text":"<p>         Bases: <code>logging.Handler</code></p> <p>Provides a logging handler that forwards all events to the Rerun SDK.</p> <p>Because Rerun's data model doesn't match 1-to-1 with the different concepts from python's logging ecosystem, we need a way to map the latter to the former:</p> <ul> <li> <p>Root Entity: Optional root entity to gather all the logs under.</p> </li> <li> <p>Entity path: the name of the logger responsible for the creation of the LogRecord                is used as the final entity path, appended after the Root Entity path.</p> </li> <li> <p>Level: the log level is mapped as-is.</p> </li> <li> <p>Body: the body of the text entry corresponds to the formatted output of         the LogRecord using the standard formatter of the logging package,         unless it has been overridden by the user.</p> </li> </ul> <p>Read more about logging handlers at https://docs.python.org/3/howto/logging.html#handlers.</p>"},{"location":"package/rerun/log/text/#rerun.log.text.LoggingHandler.emit","title":"<code>def emit(record)</code>","text":"<p>Emits a record to the Rerun SDK.</p>"},{"location":"package/rerun/log/text/#rerun.log.text.log_text_entry","title":"<code>def log_text_entry(entity_path, text, level=LogLevel.INFO, color=None, timeless=False)</code>","text":"<p>Log a text entry, with optional level.</p> <ul> <li>If no <code>level</code> is given, it will default to <code>LogLevel.INFO</code>.</li> <li><code>color</code> is optional RGB or RGBA triplet in 0-255 sRGB.</li> </ul>"},{"location":"package/rerun/log/transform/","title":"transform.py","text":""},{"location":"package/rerun/log/transform/#rerun.log.transform","title":"<code>rerun.log.transform</code>","text":""},{"location":"package/rerun/log/transform/#rerun.log.transform.log_view_coordinates","title":"<code>def log_view_coordinates(entity_path, *, xyz='', up='', right_handed=None, timeless=False)</code>","text":"<p>Log the view coordinates for an entity.</p> <p>Each entity defines its own coordinate system, called a space. By logging view coordinates you can give semantic meaning to the XYZ axes of the space. This is for instance useful for camera entities (\"what axis is forward?\").</p> <p>For full control, set the <code>xyz</code> parameter to a three-letter acronym (<code>xyz=\"RDF\"</code>). Each letter represents:</p> <ul> <li>R: Right</li> <li>L: Left</li> <li>U: Up</li> <li>D: Down</li> <li>F: Forward</li> <li>B: Back</li> </ul> <p>Some of the most common are:</p> <ul> <li>\"RDF\": X=Right Y=Down Z=Forward  (right-handed)</li> <li>\"RUB\"  X=Right Y=Up   Z=Back     (right-handed)</li> <li>\"RDB\": X=Right Y=Down Z=Back     (left-handed)</li> <li>\"RUF\": X=Right Y=Up   Z=Forward  (left-handed)</li> </ul>"},{"location":"package/rerun/log/transform/#rerun.log.transform.log_view_coordinates--example","title":"Example","text":"<pre><code>rerun.log_view_coordinates(\"world/camera\", xyz=\"RUB\")\n</code></pre> <p>For world-coordinates it's often conventient to just specify an up-axis. You can do so by using the <code>up</code>-parameter (where <code>up</code> is one of \"+X\", \"-X\", \"+Y\", \"-Y\", \"+Z\", \"-Z\"):</p> <pre><code>rerun.log_view_coordinates(\"world\", up=\"+Z\", right_handed=True, timeless=True)\nrerun.log_view_coordinates(\"world\", up=\"-Y\", right_handed=False, timeless=True)\n</code></pre>"},{"location":"package/rerun/log/transform/#rerun.log.transform.log_unknown_transform","title":"<code>def log_unknown_transform(entity_path, timeless=False)</code>","text":"<p>Log that this entity is NOT in the same space as the parent, but you do not (yet) know how they relate.</p>"},{"location":"package/rerun/log/transform/#rerun.log.transform.log_rigid3","title":"<code>def log_rigid3(entity_path, *, parent_from_child=None, child_from_parent=None, xyz='', timeless=False)</code>","text":"<p>Log a proper rigid 3D transform between this entity and the parent.</p> <p>Set either <code>parent_from_child</code> or <code>child_from_parent</code> to a tuple of <code>(translation_xyz, quat_xyzw)</code>.</p>"},{"location":"package/rerun/log/transform/#rerun.log.transform.log_rigid3--parent_from_child","title":"<code>parent_from_child</code>","text":"<p><code>parent_from_child=(translation_xyz, quat_xyzw)</code></p> <p>Also known as pose (e.g. camera extrinsics).</p> <p>The translation is the position of the entity in the parent space. The resulting transform from child to parent corresponds to taking a point in the child space, rotating it by the given rotations, and then translating it by the given translation:</p> <p>`point_parent = translation + quat * point_child * quat*</p>"},{"location":"package/rerun/log/transform/#rerun.log.transform.log_rigid3--child_from_parent","title":"<code>child_from_parent</code>","text":"<p><code>child_from_parent=(translation_xyz, quat_xyzw)</code></p> <p>the inverse of <code>parent_from_child</code></p>"},{"location":"package/rerun/log/transform/#rerun.log.transform.log_rigid3--xyz","title":"<code>xyz</code>","text":"<p>Optionally set the view coordinates of this entity, e.g. to <code>RDF</code> for <code>X=Right, Y=Down, Z=Forward</code>. This is a convenience for also calling <code>log_view_coordinates</code>.</p>"},{"location":"package/rerun/log/transform/#rerun.log.transform.log_rigid3--example","title":"Example","text":"<pre><code>rerun.log_rigid3(\"world/camera\", parent_from_child=(t,q))\nrerun.log_pinhole(\"world/camera/image\", \u2026)\n</code></pre>"}]}